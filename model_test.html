<!DOCTYPE html>
<html>

	<head>
	<title>model test</title>
	<meta charset="utf-8">
	</head>
	
	<body>
		<div id="container"></div>
		
		<script src = "js/three71.js"></script>
		<script src = "js/Detector.js"></script>
		<script src = "js/OrbitControls.js"></script>
		<script src = "js/BlendCharacter.js"></script>
		<script src="js/BlendCharacterGui.js"></script>
		<script src="js/dat.gui.min.js"></script>
		<script>
		
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container;

			var camera, scene, renderer, controls;
			
			var cameraControls;
			
			var player;
			
			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGTH = window.innerHeight;
			
			var clock = new THREE.Clock();
			
			var gui = null;

			var isFrameStepping = false;
			var timeToStep = 0;
			
			init ();			
			
			function init() {
				
				camera = new THREE.PerspectiveCamera (45, window.innerWidth / window.innerHeight, 1, 4000 );
				camera.position.set (0, 150, 300);
				
				scene = new THREE.Scene();
				
				scene.fog = new THREE.FogExp2 (0xffffff, 0.0002);
				
				scene.add(camera);
				
				scene.add(new THREE.AmbientLight( 0x222222));
				
				var light = new THREE.DirectionalLight (0xffffff, 2.25);
				light.position.set(-100, 200, -300);
				
				light.castShadow = true;
				light.shadowMapWidth = 1024;
				light.shadowMapHeight = 1024;
				light.shadowMapDarkness = 0.95;
				light.shadowCameraNear = 50;
				light.shadowCameraFar = 1000;
				//light.shadowCameraTop = 400;
				//light.shadowCameraBottom = -250;
				//light.shadowCameraRight = 900;
				//light.shadowCameraLeft = -1000;
				//light.target = (0,0,0);
				scene.add (light) ;
				
				var spotLight = new THREE.SpotLight( 0xffffff );
				spotLight.position.set( 100, 50, 100 );

				spotLight.castShadow = true;

				spotLight.shadowMapWidth = 1024;
				spotLight.shadowMapHeight = 1024;

				spotLight.shadowCameraNear = 50;
				spotLight.shadowCameraFar = 400;
				spotLight.shadowCameraFov = 45;

				scene.add( spotLight );
				
				//var gt = THREE.ImageUtils.loadTexture( "textures/grass.jpg");
				var gg = new THREE.PlaneBufferGeometry( 16000, 16000 );
				//var gm = new THREE.MeshPhongMaterial( { color: 0x333333, map: gt } );
				var gm = new THREE.MeshPhongMaterial(0xffaaee);

				var ground = new THREE.Mesh( gg, gm );
				ground.rotation.x = - Math.PI / 2;
				//ground.material.map.repeat.set( 64, 64 );
				//ground.material.map.wrapS = ground.material.map.wrapT = THREE.RepeatWrapping;
				// note that because the ground does not cast a shadow, .castShadow is left false
				ground.receiveShadow = true;

				scene.add( ground );
				
				
				var geometry = new THREE.BoxGeometry( 10, 10, 10 );
				var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
				var mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh ); 
				mesh.position.x = 30;
				mesh.position.y = 10;
				mesh.position.z = 30;
				mesh.recieveShadow = true;
				mesh.castShadow = true;
		//		var geometry = new THREE.PlaneGeometry( 2000, 2000, 32 );
		//		var material = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide} );
		//		var plane = new THREE.Mesh( geometry, material );
		//		scene.add( plane );
				
				
				//var loader = new THREE.JSONLoader();
				//loader.load('models/bot.js', createSkinnedMesh);
				//loader.load('models/simple_model1111.json', loadPlayer);
								
				
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( scene.fog.color, 1 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGTH );
				renderer.setClearColor( 0xaaaaaa, 1 );
				
				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );
				
				window.addEventListener( 'resize', onWindowResize, false );

				// listen for messages from the gui
				window.addEventListener( 'start-animation', onStartAnimation );
				window.addEventListener( 'stop-animation', onStopAnimation );
				window.addEventListener( 'pause-animation', onPauseAnimation );
				window.addEventListener( 'step-animation', onStepAnimation );
				window.addEventListener( 'weight-animation', onWeightAnimation );
				window.addEventListener( 'crossfade', onCrossfade );
				window.addEventListener( 'warp', onWarp );
				window.addEventListener( 'toggle-lock-camera', onLockCameraToggle );
				window.addEventListener( 'toggle-show-skeleton', onShowSkeleton );
				window.addEventListener( 'toggle-show-model', onShowModel );
				
				cameraControls = new THREE.OrbitControls( camera, renderer.domElement );				
				cameraControls.target.set( 0,0,0 );
				
				loader = new THREE.BlendCharacter();
				loader.load( "models/player_0.9.json", start );
				
			}
			
			function start() {

				//loader.rotation.y = Math.PI * -135 / 180;
				loader.castShadow = true;
				loader.receiveShadow = true;
				scene.add( loader );

				var aspect = window.innerWidth / window.innerHeight;
				var radius = loader.geometry.boundingSphere.radius;

				camera = new THREE.PerspectiveCamera( 45, aspect, 1, 10000 );
				camera.position.set( 0.0, radius, radius * 3.5 );

				controls = new THREE.OrbitControls( camera );
				controls.target = new THREE.Vector3( 0, radius, 0 );
				controls.update();

				// Set default weights

				loader.animations[ 'idle' ].weight = 1 / 2;
				loader.animations[ 'walk' ].weight = 1 / 2;
				//loader.animations[ 'run' ].weight = 1 / 3;
				
				gui = new BlendCharacterGui(loader.animations);
				//loader.animations[ 'walk'].play();
				animate();
			}
			
			
			function animate() {

				requestAnimationFrame( animate, renderer.domElement );

				// step forward in time based on whether we're stepping and scale

				var scale = gui.getTimeScale();
				var delta = clock.getDelta();
				var stepSize = (!isFrameStepping) ? delta * scale: timeToStep;

				// modify blend weights

				loader.update( stepSize );
				gui.update();

				THREE.AnimationHandler.update( stepSize );

				renderer.render( scene, camera );
				//stats.update();

				// if we are stepping, consume time
				// ( will equal step size next time a single step is desired )

				timeToStep = 0;

			}

		//	function loadPlayer (geometry, materials) {
		//	
		//		//var material = new THREE.MeshLambertMaterial(materials[0]);
		//		
		//		var originalMaterial = materials[ 0 ];
        //
		//		originalMaterial.skinning = true;
		//		
		//		player = new THREE.SkinnedMesh(geometry, originalMaterial);
		//		
		//				
		//		player.animations = [];
		//		
		//		for ( var i = 0; i < geometry.animations.length; ++ i ) {
		//				
		//				////v1
		//				
		//				THREE.AnimationHandler.add(geometry.animations[ i ]);
		//				
		//				var animName = geometry.animations[ i ].name;
		//				player.animations[ animName ] = new THREE.Animation( player, geometry.animations[ i ] );
		//				//ensureLoop( player.animations[ animName ]);
		//				
		//				
		//				
		//		}	
		//		
		//		//player.scale.multiplyScalar(5);
		//		player.castShadow = true;
		//		player.receiveShadow = true;
		//		
		//		scene.add(player);
		//		
		//		camera.lookAt(player.position);
		//		//skellington helper
		//		helper = new THREE.SkeletonHelper( player );
		//		
		//		helper.material.linewidth = 5;
		//		helper.visible = true;
		//		scene.add( helper );
		//	}
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onStartAnimation( event ) {

				var data = event.detail;

				loader.stopAll();

				// the blend mesh will combine 1 or more animations
				for ( var i = 0; i < data.anims.length; ++i ) {

					loader.play(data.anims[i], data.weights[i]);

				}

				isFrameStepping = false;

			}

			function onStopAnimation( event ) {

				loader.stopAll();
				isFrameStepping = false;

			}

			function onPauseAnimation( event ) {

				( isFrameStepping ) ? loader.unPauseAll(): loader.pauseAll();

				isFrameStepping = false;

			}

			function onStepAnimation( event ) {

				loader.unPauseAll();
				isFrameStepping = true;
				timeToStep = event.detail.stepSize;
			}

			function onWeightAnimation(event) {

				var data = event.detail;
				for ( var i = 0; i < data.anims.length; ++i ) {

					loader.applyWeight(data.anims[i], data.weights[i]);

				}

			}

			function onCrossfade(event) {

				var data = event.detail;

				loader.stopAll();
				loader.crossfade( data.from, data.to, data.time );

				isFrameStepping = false;

			}

			function onWarp( event ) {

				var data = event.detail;

				loader.stopAll();
				loader.warp( data.from, data.to, data.time );

				isFrameStepping = false;

			}


			function onLockCameraToggle( event ) {

				var shouldLock = event.detail.shouldLock;
				controls.enabled = !shouldLock;

			}

			function onShowSkeleton( event ) {

				var shouldShow = event.detail.shouldShow;
				loader.showSkeleton( shouldShow );

			}

			function onShowModel( event ) {

				var shouldShow = event.detail.shouldShow;
				loader.showModel( shouldShow );

			}	
			</script>
		
	</body>
</html>